{"ast":null,"code":"var Mode = require('./mode');\n/**\n * Array of characters available in alphanumeric mode\n *\n * As per QR Code specification, to each character\n * is assigned a value from 0 to 44 which in this case coincides\n * with the array index\n *\n * @type {Array}\n */\n\n\nvar ALPHA_NUM_CHARS = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', ' ', '$', '%', '*', '+', '-', '.', '/', ':'];\n\nfunction AlphanumericData(data) {\n  this.mode = Mode.ALPHANUMERIC;\n  this.data = data;\n}\n\nAlphanumericData.getBitsLength = function getBitsLength(length) {\n  return 11 * Math.floor(length / 2) + 6 * (length % 2);\n};\n\nAlphanumericData.prototype.getLength = function getLength() {\n  return this.data.length;\n};\n\nAlphanumericData.prototype.getBitsLength = function getBitsLength() {\n  return AlphanumericData.getBitsLength(this.data.length);\n};\n\nAlphanumericData.prototype.write = function write(bitBuffer) {\n  var i; // Input data characters are divided into groups of two characters\n  // and encoded as 11-bit binary codes.\n\n  for (i = 0; i + 2 <= this.data.length; i += 2) {\n    // The character value of the first character is multiplied by 45\n    var value = ALPHA_NUM_CHARS.indexOf(this.data[i]) * 45; // The character value of the second digit is added to the product\n\n    value += ALPHA_NUM_CHARS.indexOf(this.data[i + 1]); // The sum is then stored as 11-bit binary number\n\n    bitBuffer.put(value, 11);\n  } // If the number of input data characters is not a multiple of two,\n  // the character value of the final character is encoded as a 6-bit binary number.\n\n\n  if (this.data.length % 2) {\n    bitBuffer.put(ALPHA_NUM_CHARS.indexOf(this.data[i]), 6);\n  }\n};\n\nmodule.exports = AlphanumericData;","map":{"version":3,"sources":["/Users/Antonio/Desktop/SuperRent/node_modules/qrcode/lib/core/alphanumeric-data.js"],"names":["Mode","require","ALPHA_NUM_CHARS","AlphanumericData","data","mode","ALPHANUMERIC","getBitsLength","length","Math","floor","prototype","getLength","write","bitBuffer","i","value","indexOf","put","module","exports"],"mappings":"AAAA,IAAIA,IAAI,GAAGC,OAAO,CAAC,QAAD,CAAlB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,IAAIC,eAAe,GAAG,CACpB,GADoB,EACf,GADe,EACV,GADU,EACL,GADK,EACA,GADA,EACK,GADL,EACU,GADV,EACe,GADf,EACoB,GADpB,EACyB,GADzB,EAEpB,GAFoB,EAEf,GAFe,EAEV,GAFU,EAEL,GAFK,EAEA,GAFA,EAEK,GAFL,EAEU,GAFV,EAEe,GAFf,EAEoB,GAFpB,EAEyB,GAFzB,EAE8B,GAF9B,EAEmC,GAFnC,EAEwC,GAFxC,EAGpB,GAHoB,EAGf,GAHe,EAGV,GAHU,EAGL,GAHK,EAGA,GAHA,EAGK,GAHL,EAGU,GAHV,EAGe,GAHf,EAGoB,GAHpB,EAGyB,GAHzB,EAG8B,GAH9B,EAGmC,GAHnC,EAGwC,GAHxC,EAIpB,GAJoB,EAIf,GAJe,EAIV,GAJU,EAIL,GAJK,EAIA,GAJA,EAIK,GAJL,EAIU,GAJV,EAIe,GAJf,EAIoB,GAJpB,CAAtB;;AAOA,SAASC,gBAAT,CAA2BC,IAA3B,EAAiC;AAC/B,OAAKC,IAAL,GAAYL,IAAI,CAACM,YAAjB;AACA,OAAKF,IAAL,GAAYA,IAAZ;AACD;;AAEDD,gBAAgB,CAACI,aAAjB,GAAiC,SAASA,aAAT,CAAwBC,MAAxB,EAAgC;AAC/D,SAAO,KAAKC,IAAI,CAACC,KAAL,CAAWF,MAAM,GAAG,CAApB,CAAL,GAA8B,KAAKA,MAAM,GAAG,CAAd,CAArC;AACD,CAFD;;AAIAL,gBAAgB,CAACQ,SAAjB,CAA2BC,SAA3B,GAAuC,SAASA,SAAT,GAAsB;AAC3D,SAAO,KAAKR,IAAL,CAAUI,MAAjB;AACD,CAFD;;AAIAL,gBAAgB,CAACQ,SAAjB,CAA2BJ,aAA3B,GAA2C,SAASA,aAAT,GAA0B;AACnE,SAAOJ,gBAAgB,CAACI,aAAjB,CAA+B,KAAKH,IAAL,CAAUI,MAAzC,CAAP;AACD,CAFD;;AAIAL,gBAAgB,CAACQ,SAAjB,CAA2BE,KAA3B,GAAmC,SAASA,KAAT,CAAgBC,SAAhB,EAA2B;AAC5D,MAAIC,CAAJ,CAD4D,CAG5D;AACA;;AACA,OAAKA,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAG,CAAJ,IAAS,KAAKX,IAAL,CAAUI,MAA/B,EAAuCO,CAAC,IAAI,CAA5C,EAA+C;AAC7C;AACA,QAAIC,KAAK,GAAGd,eAAe,CAACe,OAAhB,CAAwB,KAAKb,IAAL,CAAUW,CAAV,CAAxB,IAAwC,EAApD,CAF6C,CAI7C;;AACAC,IAAAA,KAAK,IAAId,eAAe,CAACe,OAAhB,CAAwB,KAAKb,IAAL,CAAUW,CAAC,GAAG,CAAd,CAAxB,CAAT,CAL6C,CAO7C;;AACAD,IAAAA,SAAS,CAACI,GAAV,CAAcF,KAAd,EAAqB,EAArB;AACD,GAd2D,CAgB5D;AACA;;;AACA,MAAI,KAAKZ,IAAL,CAAUI,MAAV,GAAmB,CAAvB,EAA0B;AACxBM,IAAAA,SAAS,CAACI,GAAV,CAAchB,eAAe,CAACe,OAAhB,CAAwB,KAAKb,IAAL,CAAUW,CAAV,CAAxB,CAAd,EAAqD,CAArD;AACD;AACF,CArBD;;AAuBAI,MAAM,CAACC,OAAP,GAAiBjB,gBAAjB","sourcesContent":["var Mode = require('./mode')\n\n/**\n * Array of characters available in alphanumeric mode\n *\n * As per QR Code specification, to each character\n * is assigned a value from 0 to 44 which in this case coincides\n * with the array index\n *\n * @type {Array}\n */\nvar ALPHA_NUM_CHARS = [\n  '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n  'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',\n  'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',\n  ' ', '$', '%', '*', '+', '-', '.', '/', ':'\n]\n\nfunction AlphanumericData (data) {\n  this.mode = Mode.ALPHANUMERIC\n  this.data = data\n}\n\nAlphanumericData.getBitsLength = function getBitsLength (length) {\n  return 11 * Math.floor(length / 2) + 6 * (length % 2)\n}\n\nAlphanumericData.prototype.getLength = function getLength () {\n  return this.data.length\n}\n\nAlphanumericData.prototype.getBitsLength = function getBitsLength () {\n  return AlphanumericData.getBitsLength(this.data.length)\n}\n\nAlphanumericData.prototype.write = function write (bitBuffer) {\n  var i\n\n  // Input data characters are divided into groups of two characters\n  // and encoded as 11-bit binary codes.\n  for (i = 0; i + 2 <= this.data.length; i += 2) {\n    // The character value of the first character is multiplied by 45\n    var value = ALPHA_NUM_CHARS.indexOf(this.data[i]) * 45\n\n    // The character value of the second digit is added to the product\n    value += ALPHA_NUM_CHARS.indexOf(this.data[i + 1])\n\n    // The sum is then stored as 11-bit binary number\n    bitBuffer.put(value, 11)\n  }\n\n  // If the number of input data characters is not a multiple of two,\n  // the character value of the final character is encoded as a 6-bit binary number.\n  if (this.data.length % 2) {\n    bitBuffer.put(ALPHA_NUM_CHARS.indexOf(this.data[i]), 6)\n  }\n}\n\nmodule.exports = AlphanumericData\n"]},"metadata":{},"sourceType":"script"}