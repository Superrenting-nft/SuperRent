{"ast":null,"code":"/*\n * Emulate 'eth_accounts' / 'eth_sendTransaction' using 'eth_sendRawTransaction'\n *\n * The two callbacks a user needs to implement are:\n * - getAccounts() -- array of addresses supported\n * - signTransaction(tx) -- sign a raw transaction object\n */\nconst waterfall = require('async/waterfall');\n\nconst parallel = require('async/parallel');\n\nconst inherits = require('util').inherits;\n\nconst ethUtil = require('ethereumjs-util');\n\nconst sigUtil = require('eth-sig-util');\n\nconst extend = require('xtend');\n\nconst Semaphore = require('semaphore');\n\nconst Subprovider = require('./subprovider.js');\n\nconst estimateGas = require('../util/estimate-gas.js');\n\nconst hexRegex = /^[0-9A-Fa-f]+$/g;\nmodule.exports = HookedWalletSubprovider; // handles the following RPC methods:\n//   eth_coinbase\n//   eth_accounts\n//   eth_sendTransaction\n//   eth_sign\n//   eth_signTypedData\n//   eth_signTypedData_v3\n//   eth_signTypedData_v4\n//   personal_sign\n//   eth_decryptMessage\n//   encryption_public_key\n//   personal_ecRecover\n//   parity_postTransaction\n//   parity_checkRequest\n//   parity_defaultAccount\n//\n// Tx Signature Flow\n//\n// handleRequest: eth_sendTransaction\n//   validateTransaction (basic validity check)\n//     validateSender (checks that sender is in accounts)\n//   processTransaction (sign tx and submit to network)\n//     approveTransaction (UI approval hook)\n//     checkApproval\n//     finalizeAndSubmitTx (tx signing)\n//       nonceLock.take (bottle neck to ensure atomic nonce)\n//         fillInTxExtras (set fallback gasPrice, nonce, etc)\n//         signTransaction (perform the signature)\n//         publishTransaction (publish signed tx to network)\n//\n\ninherits(HookedWalletSubprovider, Subprovider);\n\nfunction HookedWalletSubprovider(opts) {\n  const self = this; // control flow\n\n  self.nonceLock = Semaphore(1); // data lookup\n\n  if (opts.getAccounts) self.getAccounts = opts.getAccounts; // high level override\n\n  if (opts.processTransaction) self.processTransaction = opts.processTransaction;\n  if (opts.processMessage) self.processMessage = opts.processMessage;\n  if (opts.processPersonalMessage) self.processPersonalMessage = opts.processPersonalMessage;\n  if (opts.processTypedMessage) self.processTypedMessage = opts.processTypedMessage; // approval hooks\n\n  self.approveTransaction = opts.approveTransaction || self.autoApprove;\n  self.approveMessage = opts.approveMessage || self.autoApprove;\n  self.approvePersonalMessage = opts.approvePersonalMessage || self.autoApprove;\n  self.approveDecryptMessage = opts.approveDecryptMessage || self.autoApprove;\n  self.approveEncryptionPublicKey = opts.approveEncryptionPublicKey || self.autoApprove;\n  self.approveTypedMessage = opts.approveTypedMessage || self.autoApprove; // actually perform the signature\n\n  if (opts.signTransaction) self.signTransaction = opts.signTransaction || mustProvideInConstructor('signTransaction');\n  if (opts.signMessage) self.signMessage = opts.signMessage || mustProvideInConstructor('signMessage');\n  if (opts.signPersonalMessage) self.signPersonalMessage = opts.signPersonalMessage || mustProvideInConstructor('signPersonalMessage');\n  if (opts.decryptMessage) self.decryptMessage = opts.decryptMessage || mustProvideInConstructor('decryptMessage');\n  if (opts.encryptionPublicKey) self.encryptionPublicKey = opts.encryptionPublicKey || mustProvideInConstructor('encryptionPublicKey');\n  if (opts.signTypedMessage) self.signTypedMessage = opts.signTypedMessage || mustProvideInConstructor('signTypedMessage');\n  if (opts.recoverPersonalSignature) self.recoverPersonalSignature = opts.recoverPersonalSignature; // publish to network\n\n  if (opts.publishTransaction) self.publishTransaction = opts.publishTransaction; // gas options\n\n  self.estimateGas = opts.estimateGas || self.estimateGas;\n  self.getGasPrice = opts.getGasPrice || self.getGasPrice;\n}\n\nHookedWalletSubprovider.prototype.handleRequest = function (payload, next, end) {\n  const self = this;\n  self._parityRequests = {};\n  self._parityRequestCount = 0; // switch statement is not block scoped\n  // sp we cant repeat var declarations\n\n  let txParams, msgParams, extraParams;\n  let message, address;\n\n  switch (payload.method) {\n    case 'eth_coinbase':\n      // process normally\n      self.getAccounts(function (err, accounts) {\n        if (err) return end(err);\n        let result = accounts[0] || null;\n        end(null, result);\n      });\n      return;\n\n    case 'eth_accounts':\n      // process normally\n      self.getAccounts(function (err, accounts) {\n        if (err) return end(err);\n        end(null, accounts);\n      });\n      return;\n\n    case 'eth_sendTransaction':\n      txParams = payload.params[0];\n      waterfall([cb => self.validateTransaction(txParams, cb), cb => self.processTransaction(txParams, cb)], end);\n      return;\n\n    case 'eth_signTransaction':\n      txParams = payload.params[0];\n      waterfall([cb => self.validateTransaction(txParams, cb), cb => self.processSignTransaction(txParams, cb)], end);\n      return;\n\n    case 'eth_sign':\n      // process normally\n      address = payload.params[0];\n      message = payload.params[1]; // non-standard \"extraParams\" to be appended to our \"msgParams\" obj\n      // good place for metadata\n\n      extraParams = payload.params[2] || {};\n      msgParams = extend(extraParams, {\n        from: address,\n        data: message\n      });\n      waterfall([cb => self.validateMessage(msgParams, cb), cb => self.processMessage(msgParams, cb)], end);\n      return;\n\n    case 'personal_sign':\n      return function () {\n        // process normally\n        const first = payload.params[0];\n        const second = payload.params[1]; // We initially incorrectly ordered these parameters.\n        // To gracefully respect users who adopted this API early,\n        // we are currently gracefully recovering from the wrong param order\n        // when it is clearly identifiable.\n        //\n        // That means when the first param is definitely an address,\n        // and the second param is definitely not, but is hex.\n\n        if (resemblesData(second) && resemblesAddress(first)) {\n          let warning = `The eth_personalSign method requires params ordered `;\n          warning += `[message, address]. This was previously handled incorrectly, `;\n          warning += `and has been corrected automatically. `;\n          warning += `Please switch this param order for smooth behavior in the future.`;\n          console.warn(warning);\n          address = payload.params[0];\n          message = payload.params[1];\n        } else {\n          message = payload.params[0];\n          address = payload.params[1];\n        } // non-standard \"extraParams\" to be appended to our \"msgParams\" obj\n        // good place for metadata\n\n\n        extraParams = payload.params[2] || {};\n        msgParams = extend(extraParams, {\n          from: address,\n          data: message\n        });\n        waterfall([cb => self.validatePersonalMessage(msgParams, cb), cb => self.processPersonalMessage(msgParams, cb)], end);\n      }();\n\n    case 'eth_decryptMessage':\n      return function () {\n        // process normally\n        const first = payload.params[0];\n        const second = payload.params[1]; // We initially incorrectly ordered these parameters.\n        // To gracefully respect users who adopted this API early,\n        // we are currently gracefully recovering from the wrong param order\n        // when it is clearly identifiable.\n        //\n        // That means when the first param is definitely an address,\n        // and the second param is definitely not, but is hex.\n\n        if (resemblesData(second) && resemblesAddress(first)) {\n          let warning = `The eth_decryptMessage method requires params ordered `;\n          warning += `[message, address]. This was previously handled incorrectly, `;\n          warning += `and has been corrected automatically. `;\n          warning += `Please switch this param order for smooth behavior in the future.`;\n          console.warn(warning);\n          address = payload.params[0];\n          message = payload.params[1];\n        } else {\n          message = payload.params[0];\n          address = payload.params[1];\n        } // non-standard \"extraParams\" to be appended to our \"msgParams\" obj\n        // good place for metadata\n\n\n        extraParams = payload.params[2] || {};\n        msgParams = extend(extraParams, {\n          from: address,\n          data: message\n        });\n        waterfall([cb => self.validateDecryptMessage(msgParams, cb), cb => self.processDecryptMessage(msgParams, cb)], end);\n      }();\n\n    case 'encryption_public_key':\n      return function () {\n        const address = payload.params[0];\n        waterfall([cb => self.validateEncryptionPublicKey(address, cb), cb => self.processEncryptionPublicKey(address, cb)], end);\n      }();\n\n    case 'personal_ecRecover':\n      return function () {\n        message = payload.params[0];\n        let signature = payload.params[1]; // non-standard \"extraParams\" to be appended to our \"msgParams\" obj\n        // good place for metadata\n\n        extraParams = payload.params[2] || {};\n        msgParams = extend(extraParams, {\n          sig: signature,\n          data: message\n        });\n        self.recoverPersonalSignature(msgParams, end);\n      }();\n\n    case 'eth_signTypedData':\n    case 'eth_signTypedData_v3':\n    case 'eth_signTypedData_v4':\n      return function () {\n        // process normally\n        const first = payload.params[0];\n        const second = payload.params[1];\n\n        if (resemblesAddress(first)) {\n          address = first;\n          message = second;\n        } else {\n          message = first;\n          address = second;\n        }\n\n        extraParams = payload.params[2] || {};\n        msgParams = extend(extraParams, {\n          from: address,\n          data: message\n        });\n        waterfall([cb => self.validateTypedMessage(msgParams, cb), cb => self.processTypedMessage(msgParams, cb)], end);\n      }();\n\n    case 'parity_postTransaction':\n      txParams = payload.params[0];\n      self.parityPostTransaction(txParams, end);\n      return;\n\n    case 'parity_postSign':\n      address = payload.params[0];\n      message = payload.params[1];\n      self.parityPostSign(address, message, end);\n      return;\n\n    case 'parity_checkRequest':\n      return function () {\n        const requestId = payload.params[0];\n        self.parityCheckRequest(requestId, end);\n      }();\n\n    case 'parity_defaultAccount':\n      self.getAccounts(function (err, accounts) {\n        if (err) return end(err);\n        const account = accounts[0] || null;\n        end(null, account);\n      });\n      return;\n\n    default:\n      next();\n      return;\n  }\n}; //\n// data lookup\n//\n\n\nHookedWalletSubprovider.prototype.getAccounts = function (cb) {\n  cb(null, []);\n}; //\n// \"process\" high level flow\n//\n\n\nHookedWalletSubprovider.prototype.processTransaction = function (txParams, cb) {\n  const self = this;\n  waterfall([cb => self.approveTransaction(txParams, cb), (didApprove, cb) => self.checkApproval('transaction', didApprove, cb), cb => self.finalizeAndSubmitTx(txParams, cb)], cb);\n};\n\nHookedWalletSubprovider.prototype.processSignTransaction = function (txParams, cb) {\n  const self = this;\n  waterfall([cb => self.approveTransaction(txParams, cb), (didApprove, cb) => self.checkApproval('transaction', didApprove, cb), cb => self.finalizeTx(txParams, cb)], cb);\n};\n\nHookedWalletSubprovider.prototype.processMessage = function (msgParams, cb) {\n  const self = this;\n  waterfall([cb => self.approveMessage(msgParams, cb), (didApprove, cb) => self.checkApproval('message', didApprove, cb), cb => self.signMessage(msgParams, cb)], cb);\n};\n\nHookedWalletSubprovider.prototype.processPersonalMessage = function (msgParams, cb) {\n  const self = this;\n  waterfall([cb => self.approvePersonalMessage(msgParams, cb), (didApprove, cb) => self.checkApproval('message', didApprove, cb), cb => self.signPersonalMessage(msgParams, cb)], cb);\n};\n\nHookedWalletSubprovider.prototype.processDecryptMessage = function (msgParams, cb) {\n  const self = this;\n  waterfall([cb => self.approveDecryptMessage(msgParams, cb), (didApprove, cb) => self.checkApproval('decryptMessage', didApprove, cb), cb => self.decryptMessage(msgParams, cb)], cb);\n};\n\nHookedWalletSubprovider.prototype.processEncryptionPublicKey = function (msgParams, cb) {\n  const self = this;\n  waterfall([cb => self.approveEncryptionPublicKey(msgParams, cb), (didApprove, cb) => self.checkApproval('encryptionPublicKey', didApprove, cb), cb => self.encryptionPublicKey(msgParams, cb)], cb);\n};\n\nHookedWalletSubprovider.prototype.processTypedMessage = function (msgParams, cb) {\n  const self = this;\n  waterfall([cb => self.approveTypedMessage(msgParams, cb), (didApprove, cb) => self.checkApproval('message', didApprove, cb), cb => self.signTypedMessage(msgParams, cb)], cb);\n}; //\n// approval\n//\n\n\nHookedWalletSubprovider.prototype.autoApprove = function (txParams, cb) {\n  cb(null, true);\n};\n\nHookedWalletSubprovider.prototype.checkApproval = function (type, didApprove, cb) {\n  cb(didApprove ? null : new Error('User denied ' + type + ' signature.'));\n}; //\n// parity\n//\n\n\nHookedWalletSubprovider.prototype.parityPostTransaction = function (txParams, cb) {\n  const self = this; // get next id\n\n  const count = self._parityRequestCount;\n  const reqId = `0x${count.toString(16)}`;\n  self._parityRequestCount++;\n  self.emitPayload({\n    method: 'eth_sendTransaction',\n    params: [txParams]\n  }, function (error, res) {\n    if (error) {\n      self._parityRequests[reqId] = {\n        error\n      };\n      return;\n    }\n\n    const txHash = res.result;\n    self._parityRequests[reqId] = txHash;\n  });\n  cb(null, reqId);\n};\n\nHookedWalletSubprovider.prototype.parityPostSign = function (address, message, cb) {\n  const self = this; // get next id\n\n  const count = self._parityRequestCount;\n  const reqId = `0x${count.toString(16)}`;\n  self._parityRequestCount++;\n  self.emitPayload({\n    method: 'eth_sign',\n    params: [address, message]\n  }, function (error, res) {\n    if (error) {\n      self._parityRequests[reqId] = {\n        error\n      };\n      return;\n    }\n\n    const result = res.result;\n    self._parityRequests[reqId] = result;\n  });\n  cb(null, reqId);\n};\n\nHookedWalletSubprovider.prototype.parityCheckRequest = function (reqId, cb) {\n  const self = this;\n  const result = self._parityRequests[reqId] || null; // tx not handled yet\n\n  if (!result) return cb(null, null); // tx was rejected (or other error)\n\n  if (result.error) return cb(result.error); // tx sent\n\n  cb(null, result);\n}; //\n// signature and recovery\n//\n\n\nHookedWalletSubprovider.prototype.recoverPersonalSignature = function (msgParams, cb) {\n  let senderHex;\n\n  try {\n    senderHex = sigUtil.recoverPersonalSignature(msgParams);\n  } catch (err) {\n    return cb(err);\n  }\n\n  cb(null, senderHex);\n}; //\n// validation\n//\n\n\nHookedWalletSubprovider.prototype.validateTransaction = function (txParams, cb) {\n  const self = this; // shortcut: undefined sender is invalid\n\n  if (txParams.from === undefined) return cb(new Error(`Undefined address - from address required to sign transaction.`));\n  self.validateSender(txParams.from, function (err, senderIsValid) {\n    if (err) return cb(err);\n    if (!senderIsValid) return cb(new Error(`Unknown address - unable to sign transaction for this address: \"${txParams.from}\"`));\n    cb();\n  });\n};\n\nHookedWalletSubprovider.prototype.validateMessage = function (msgParams, cb) {\n  const self = this;\n  if (msgParams.from === undefined) return cb(new Error(`Undefined address - from address required to sign message.`));\n  self.validateSender(msgParams.from, function (err, senderIsValid) {\n    if (err) return cb(err);\n    if (!senderIsValid) return cb(new Error(`Unknown address - unable to sign message for this address: \"${msgParams.from}\"`));\n    cb();\n  });\n};\n\nHookedWalletSubprovider.prototype.validatePersonalMessage = function (msgParams, cb) {\n  const self = this;\n  if (msgParams.from === undefined) return cb(new Error(`Undefined address - from address required to sign personal message.`));\n  if (msgParams.data === undefined) return cb(new Error(`Undefined message - message required to sign personal message.`));\n  if (!isValidHex(msgParams.data)) return cb(new Error(`HookedWalletSubprovider - validateMessage - message was not encoded as hex.`));\n  self.validateSender(msgParams.from, function (err, senderIsValid) {\n    if (err) return cb(err);\n    if (!senderIsValid) return cb(new Error(`Unknown address - unable to sign message for this address: \"${msgParams.from}\"`));\n    cb();\n  });\n};\n\nHookedWalletSubprovider.prototype.validateDecryptMessage = function (msgParams, cb) {\n  const self = this;\n  if (msgParams.from === undefined) return cb(new Error(`Undefined address - from address required to decrypt message.`));\n  if (msgParams.data === undefined) return cb(new Error(`Undefined message - message required to decrypt message.`));\n  if (!isValidHex(msgParams.data)) return cb(new Error(`HookedWalletSubprovider - validateDecryptMessage - message was not encoded as hex.`));\n  self.validateSender(msgParams.from, function (err, senderIsValid) {\n    if (err) return cb(err);\n    if (!senderIsValid) return cb(new Error(`Unknown address - unable to decrypt message for this address: \"${msgParams.from}\"`));\n    cb();\n  });\n};\n\nHookedWalletSubprovider.prototype.validateEncryptionPublicKey = function (address, cb) {\n  const self = this;\n  self.validateSender(address, function (err, senderIsValid) {\n    if (err) return cb(err);\n    if (!senderIsValid) return cb(new Error(`Unknown address - unable to obtain encryption public key for this address: \"${address}\"`));\n    cb();\n  });\n};\n\nHookedWalletSubprovider.prototype.validateTypedMessage = function (msgParams, cb) {\n  if (msgParams.from === undefined) return cb(new Error(`Undefined address - from address required to sign typed data.`));\n  if (msgParams.data === undefined) return cb(new Error(`Undefined data - message required to sign typed data.`));\n  this.validateSender(msgParams.from, function (err, senderIsValid) {\n    if (err) return cb(err);\n    if (!senderIsValid) return cb(new Error(`Unknown address - unable to sign message for this address: \"${msgParams.from}\"`));\n    cb();\n  });\n};\n\nHookedWalletSubprovider.prototype.validateSender = function (senderAddress, cb) {\n  const self = this; // shortcut: undefined sender is invalid\n\n  if (!senderAddress) return cb(null, false);\n  self.getAccounts(function (err, accounts) {\n    if (err) return cb(err);\n    const senderIsValid = accounts.map(toLowerCase).indexOf(senderAddress.toLowerCase()) !== -1;\n    cb(null, senderIsValid);\n  });\n}; //\n// tx helpers\n//\n\n\nHookedWalletSubprovider.prototype.finalizeAndSubmitTx = function (txParams, cb) {\n  const self = this; // can only allow one tx to pass through this flow at a time\n  // so we can atomically consume a nonce\n\n  self.nonceLock.take(function () {\n    waterfall([self.fillInTxExtras.bind(self, txParams), self.signTransaction.bind(self), self.publishTransaction.bind(self)], function (err, txHash) {\n      self.nonceLock.leave();\n      if (err) return cb(err);\n      cb(null, txHash);\n    });\n  });\n};\n\nHookedWalletSubprovider.prototype.finalizeTx = function (txParams, cb) {\n  const self = this; // can only allow one tx to pass through this flow at a time\n  // so we can atomically consume a nonce\n\n  self.nonceLock.take(function () {\n    waterfall([self.fillInTxExtras.bind(self, txParams), self.signTransaction.bind(self)], function (err, signedTx) {\n      self.nonceLock.leave();\n      if (err) return cb(err);\n      cb(null, {\n        raw: signedTx,\n        tx: txParams\n      });\n    });\n  });\n};\n\nHookedWalletSubprovider.prototype.publishTransaction = function (rawTx, cb) {\n  const self = this;\n  self.emitPayload({\n    method: 'eth_sendRawTransaction',\n    params: [rawTx]\n  }, function (err, res) {\n    if (err) return cb(err);\n    cb(null, res.result);\n  });\n};\n\nHookedWalletSubprovider.prototype.estimateGas = function (txParams, cb) {\n  const self = this;\n  estimateGas(self.engine, txParams, cb);\n};\n\nHookedWalletSubprovider.prototype.getGasPrice = function (cb) {\n  const self = this;\n  self.emitPayload({\n    method: 'eth_gasPrice',\n    params: []\n  }, function (err, res) {\n    if (err) return cb(err);\n    cb(null, res.result);\n  });\n};\n\nHookedWalletSubprovider.prototype.fillInTxExtras = function (txParams, cb) {\n  const self = this;\n  const address = txParams.from; // console.log('fillInTxExtras - address:', address)\n\n  const tasks = {};\n\n  if (txParams.gasPrice === undefined) {\n    // console.log(\"need to get gasprice\")\n    tasks.gasPrice = self.getGasPrice.bind(self);\n  }\n\n  if (txParams.nonce === undefined) {\n    // console.log(\"need to get nonce\")\n    tasks.nonce = self.emitPayload.bind(self, {\n      method: 'eth_getTransactionCount',\n      params: [address, 'pending']\n    });\n  }\n\n  if (txParams.gas === undefined) {\n    // console.log(\"need to get gas\")\n    tasks.gas = self.estimateGas.bind(self, cloneTxParams(txParams));\n  }\n\n  parallel(tasks, function (err, taskResults) {\n    if (err) return cb(err);\n    const result = {};\n    if (taskResults.gasPrice) result.gasPrice = taskResults.gasPrice;\n    if (taskResults.nonce) result.nonce = taskResults.nonce.result;\n    if (taskResults.gas) result.gas = taskResults.gas;\n    cb(null, extend(txParams, result));\n  });\n}; // util\n// we use this to clean any custom params from the txParams\n\n\nfunction cloneTxParams(txParams) {\n  return {\n    from: txParams.from,\n    to: txParams.to,\n    value: txParams.value,\n    data: txParams.data,\n    gas: txParams.gas,\n    gasPrice: txParams.gasPrice,\n    nonce: txParams.nonce\n  };\n}\n\nfunction toLowerCase(string) {\n  return string.toLowerCase();\n}\n\nfunction resemblesAddress(string) {\n  const fixed = ethUtil.addHexPrefix(string);\n  const isValid = ethUtil.isValidAddress(fixed);\n  return isValid;\n} // Returns true if resembles hex data\n// but definitely not a valid address.\n\n\nfunction resemblesData(string) {\n  const fixed = ethUtil.addHexPrefix(string);\n  const isValidAddress = ethUtil.isValidAddress(fixed);\n  return !isValidAddress && isValidHex(string);\n}\n\nfunction isValidHex(data) {\n  const isString = typeof data === 'string';\n  if (!isString) return false;\n  const isHexPrefixed = data.slice(0, 2) === '0x';\n  if (!isHexPrefixed) return false;\n  const nonPrefixed = data.slice(2);\n  const isValid = nonPrefixed.match(hexRegex);\n  return isValid;\n}\n\nfunction mustProvideInConstructor(methodName) {\n  return function (params, cb) {\n    cb(new Error('ProviderEngine - HookedWalletSubprovider - Must provide \"' + methodName + '\" fn in constructor options'));\n  };\n}","map":{"version":3,"sources":["/Users/Antonio/Desktop/SuperRent/node_modules/web3-provider-engine/subproviders/hooked-wallet.js"],"names":["waterfall","require","parallel","inherits","ethUtil","sigUtil","extend","Semaphore","Subprovider","estimateGas","hexRegex","module","exports","HookedWalletSubprovider","opts","self","nonceLock","getAccounts","processTransaction","processMessage","processPersonalMessage","processTypedMessage","approveTransaction","autoApprove","approveMessage","approvePersonalMessage","approveDecryptMessage","approveEncryptionPublicKey","approveTypedMessage","signTransaction","mustProvideInConstructor","signMessage","signPersonalMessage","decryptMessage","encryptionPublicKey","signTypedMessage","recoverPersonalSignature","publishTransaction","getGasPrice","prototype","handleRequest","payload","next","end","_parityRequests","_parityRequestCount","txParams","msgParams","extraParams","message","address","method","err","accounts","result","params","cb","validateTransaction","processSignTransaction","from","data","validateMessage","first","second","resemblesData","resemblesAddress","warning","console","warn","validatePersonalMessage","validateDecryptMessage","processDecryptMessage","validateEncryptionPublicKey","processEncryptionPublicKey","signature","sig","validateTypedMessage","parityPostTransaction","parityPostSign","requestId","parityCheckRequest","account","didApprove","checkApproval","finalizeAndSubmitTx","finalizeTx","type","Error","count","reqId","toString","emitPayload","error","res","txHash","senderHex","undefined","validateSender","senderIsValid","isValidHex","senderAddress","map","toLowerCase","indexOf","take","fillInTxExtras","bind","leave","signedTx","raw","tx","rawTx","engine","tasks","gasPrice","nonce","gas","cloneTxParams","taskResults","to","value","string","fixed","addHexPrefix","isValid","isValidAddress","isString","isHexPrefixed","slice","nonPrefixed","match","methodName"],"mappings":"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","sourcesContent":["/*\n * Emulate 'eth_accounts' / 'eth_sendTransaction' using 'eth_sendRawTransaction'\n *\n * The two callbacks a user needs to implement are:\n * - getAccounts() -- array of addresses supported\n * - signTransaction(tx) -- sign a raw transaction object\n */\n\nconst waterfall = require('async/waterfall')\nconst parallel = require('async/parallel')\nconst inherits = require('util').inherits\nconst ethUtil = require('ethereumjs-util')\nconst sigUtil = require('eth-sig-util')\nconst extend = require('xtend')\nconst Semaphore = require('semaphore')\nconst Subprovider = require('./subprovider.js')\nconst estimateGas = require('../util/estimate-gas.js')\nconst hexRegex = /^[0-9A-Fa-f]+$/g\n\nmodule.exports = HookedWalletSubprovider\n\n// handles the following RPC methods:\n//   eth_coinbase\n//   eth_accounts\n//   eth_sendTransaction\n//   eth_sign\n//   eth_signTypedData\n//   eth_signTypedData_v3\n//   eth_signTypedData_v4\n//   personal_sign\n//   eth_decryptMessage\n//   encryption_public_key\n//   personal_ecRecover\n//   parity_postTransaction\n//   parity_checkRequest\n//   parity_defaultAccount\n\n//\n// Tx Signature Flow\n//\n// handleRequest: eth_sendTransaction\n//   validateTransaction (basic validity check)\n//     validateSender (checks that sender is in accounts)\n//   processTransaction (sign tx and submit to network)\n//     approveTransaction (UI approval hook)\n//     checkApproval\n//     finalizeAndSubmitTx (tx signing)\n//       nonceLock.take (bottle neck to ensure atomic nonce)\n//         fillInTxExtras (set fallback gasPrice, nonce, etc)\n//         signTransaction (perform the signature)\n//         publishTransaction (publish signed tx to network)\n//\n\n\ninherits(HookedWalletSubprovider, Subprovider)\n\nfunction HookedWalletSubprovider(opts){\n  const self = this\n  // control flow\n  self.nonceLock = Semaphore(1)\n\n  // data lookup\n  if (opts.getAccounts) self.getAccounts = opts.getAccounts\n  // high level override\n  if (opts.processTransaction) self.processTransaction = opts.processTransaction\n  if (opts.processMessage) self.processMessage = opts.processMessage\n  if (opts.processPersonalMessage) self.processPersonalMessage = opts.processPersonalMessage\n  if (opts.processTypedMessage) self.processTypedMessage = opts.processTypedMessage\n  // approval hooks\n  self.approveTransaction = opts.approveTransaction || self.autoApprove\n  self.approveMessage = opts.approveMessage || self.autoApprove\n  self.approvePersonalMessage = opts.approvePersonalMessage || self.autoApprove\n  self.approveDecryptMessage = opts.approveDecryptMessage || self.autoApprove\n  self.approveEncryptionPublicKey = opts.approveEncryptionPublicKey || self.autoApprove\n  self.approveTypedMessage = opts.approveTypedMessage || self.autoApprove\n  // actually perform the signature\n  if (opts.signTransaction) self.signTransaction = opts.signTransaction  || mustProvideInConstructor('signTransaction')\n  if (opts.signMessage) self.signMessage = opts.signMessage  || mustProvideInConstructor('signMessage')\n  if (opts.signPersonalMessage) self.signPersonalMessage = opts.signPersonalMessage  || mustProvideInConstructor('signPersonalMessage')\n  if (opts.decryptMessage) self.decryptMessage = opts.decryptMessage  || mustProvideInConstructor('decryptMessage')\n  if (opts.encryptionPublicKey) self.encryptionPublicKey = opts.encryptionPublicKey  || mustProvideInConstructor('encryptionPublicKey')\n  if (opts.signTypedMessage) self.signTypedMessage = opts.signTypedMessage  || mustProvideInConstructor('signTypedMessage')\n  if (opts.recoverPersonalSignature) self.recoverPersonalSignature = opts.recoverPersonalSignature\n  // publish to network\n  if (opts.publishTransaction) self.publishTransaction = opts.publishTransaction\n  // gas options\n  self.estimateGas = opts.estimateGas || self.estimateGas\n  self.getGasPrice = opts.getGasPrice || self.getGasPrice\n}\n\nHookedWalletSubprovider.prototype.handleRequest = function(payload, next, end){\n  const self = this\n  self._parityRequests = {}\n  self._parityRequestCount = 0\n\n  // switch statement is not block scoped\n  // sp we cant repeat var declarations\n  let txParams, msgParams, extraParams\n  let message, address\n\n  switch(payload.method) {\n\n    case 'eth_coinbase':\n      // process normally\n      self.getAccounts(function(err, accounts){\n        if (err) return end(err)\n        let result = accounts[0] || null\n        end(null, result)\n      })\n      return\n\n    case 'eth_accounts':\n      // process normally\n      self.getAccounts(function(err, accounts){\n        if (err) return end(err)\n        end(null, accounts)\n      })\n      return\n\n    case 'eth_sendTransaction':\n      txParams = payload.params[0]\n      waterfall([\n        (cb) => self.validateTransaction(txParams, cb),\n        (cb) => self.processTransaction(txParams, cb),\n      ], end)\n      return\n\n    case 'eth_signTransaction':\n      txParams = payload.params[0]\n      waterfall([\n        (cb) => self.validateTransaction(txParams, cb),\n        (cb) => self.processSignTransaction(txParams, cb),\n      ], end)\n      return\n\n    case 'eth_sign':\n      // process normally\n      address = payload.params[0]\n      message = payload.params[1]\n      // non-standard \"extraParams\" to be appended to our \"msgParams\" obj\n      // good place for metadata\n      extraParams = payload.params[2] || {}\n      msgParams = extend(extraParams, {\n        from: address,\n        data: message,\n      })\n      waterfall([\n        (cb) => self.validateMessage(msgParams, cb),\n        (cb) => self.processMessage(msgParams, cb),\n      ], end)\n      return\n\n    case 'personal_sign':\n      return (function(){\n        // process normally\n        const first = payload.params[0]\n        const second = payload.params[1]\n\n        // We initially incorrectly ordered these parameters.\n        // To gracefully respect users who adopted this API early,\n        // we are currently gracefully recovering from the wrong param order\n        // when it is clearly identifiable.\n        //\n        // That means when the first param is definitely an address,\n        // and the second param is definitely not, but is hex.\n        if (resemblesData(second) && resemblesAddress(first)) {\n          let warning = `The eth_personalSign method requires params ordered `\n          warning += `[message, address]. This was previously handled incorrectly, `\n          warning += `and has been corrected automatically. `\n          warning += `Please switch this param order for smooth behavior in the future.`\n          console.warn(warning)\n\n          address = payload.params[0]\n          message = payload.params[1]\n        } else {\n          message = payload.params[0]\n          address = payload.params[1]\n        }\n\n        // non-standard \"extraParams\" to be appended to our \"msgParams\" obj\n        // good place for metadata\n        extraParams = payload.params[2] || {}\n        msgParams = extend(extraParams, {\n          from: address,\n          data: message,\n        })\n        waterfall([\n          (cb) => self.validatePersonalMessage(msgParams, cb),\n          (cb) => self.processPersonalMessage(msgParams, cb),\n        ], end)\n      })()\n\n    case 'eth_decryptMessage':\n      return (function(){\n        // process normally\n        const first = payload.params[0]\n        const second = payload.params[1]\n\n        // We initially incorrectly ordered these parameters.\n        // To gracefully respect users who adopted this API early,\n        // we are currently gracefully recovering from the wrong param order\n        // when it is clearly identifiable.\n        //\n        // That means when the first param is definitely an address,\n        // and the second param is definitely not, but is hex.\n        if (resemblesData(second) && resemblesAddress(first)) {\n          let warning = `The eth_decryptMessage method requires params ordered `\n          warning += `[message, address]. This was previously handled incorrectly, `\n          warning += `and has been corrected automatically. `\n          warning += `Please switch this param order for smooth behavior in the future.`\n          console.warn(warning)\n\n          address = payload.params[0]\n          message = payload.params[1]\n        } else {\n          message = payload.params[0]\n          address = payload.params[1]\n        }\n\n        // non-standard \"extraParams\" to be appended to our \"msgParams\" obj\n        // good place for metadata\n        extraParams = payload.params[2] || {}\n        msgParams = extend(extraParams, {\n          from: address,\n          data: message,\n        })\n        waterfall([\n          (cb) => self.validateDecryptMessage(msgParams, cb),\n          (cb) => self.processDecryptMessage(msgParams, cb),\n        ], end)\n      })()\n      \n    case 'encryption_public_key':\n      return (function(){\n        const address = payload.params[0]\n        \n        waterfall([\n          (cb) => self.validateEncryptionPublicKey(address, cb),\n          (cb) => self.processEncryptionPublicKey(address, cb),\n        ], end)\n      })()\n      \n    case 'personal_ecRecover':\n      return (function(){    \n        message = payload.params[0]\n        let signature = payload.params[1]\n        // non-standard \"extraParams\" to be appended to our \"msgParams\" obj\n        // good place for metadata\n        extraParams = payload.params[2] || {}\n        msgParams = extend(extraParams, {\n          sig: signature,\n          data: message,\n        })\n        self.recoverPersonalSignature(msgParams, end)\n      })()\n\n    case 'eth_signTypedData':\n    case 'eth_signTypedData_v3':\n    case 'eth_signTypedData_v4':\n      return (function(){ \n        // process normally\n      \n        const first = payload.params[0]\n        const second = payload.params[1]\n\n        if (resemblesAddress(first)) {\n          address = first\n          message = second\n        } else {\n          message = first\n          address = second\n        }\n\n        extraParams = payload.params[2] || {}\n        msgParams = extend(extraParams, {\n          from: address,\n          data: message,\n        })\n        waterfall([\n          (cb) => self.validateTypedMessage(msgParams, cb),\n          (cb) => self.processTypedMessage(msgParams, cb),\n        ], end)\n      })()\n\n    case 'parity_postTransaction':\n      txParams = payload.params[0]\n      self.parityPostTransaction(txParams, end)\n      return\n\n    case 'parity_postSign':\n      address = payload.params[0]\n      message = payload.params[1]\n      self.parityPostSign(address, message, end)\n      return\n\n    case 'parity_checkRequest':\n      return (function(){\n        const requestId = payload.params[0]\n        self.parityCheckRequest(requestId, end)\n      })()\n\n    case 'parity_defaultAccount':\n      self.getAccounts(function(err, accounts){\n        if (err) return end(err)\n        const account = accounts[0] || null\n        end(null, account)\n      })\n      return\n\n    default:\n      next()\n      return\n\n  }\n}\n\n//\n// data lookup\n//\n\nHookedWalletSubprovider.prototype.getAccounts = function(cb) {\n  cb(null, [])\n}\n\n\n//\n// \"process\" high level flow\n//\n\nHookedWalletSubprovider.prototype.processTransaction = function(txParams, cb) {\n  const self = this\n  waterfall([\n    (cb) => self.approveTransaction(txParams, cb),\n    (didApprove, cb) => self.checkApproval('transaction', didApprove, cb),\n    (cb) => self.finalizeAndSubmitTx(txParams, cb),\n  ], cb)\n}\n\n\nHookedWalletSubprovider.prototype.processSignTransaction = function(txParams, cb) {\n  const self = this\n  waterfall([\n    (cb) => self.approveTransaction(txParams, cb),\n    (didApprove, cb) => self.checkApproval('transaction', didApprove, cb),\n    (cb) => self.finalizeTx(txParams, cb),\n  ], cb)\n}\n\nHookedWalletSubprovider.prototype.processMessage = function(msgParams, cb) {\n  const self = this\n  waterfall([\n    (cb) => self.approveMessage(msgParams, cb),\n    (didApprove, cb) => self.checkApproval('message', didApprove, cb),\n    (cb) => self.signMessage(msgParams, cb),\n  ], cb)\n}\n\nHookedWalletSubprovider.prototype.processPersonalMessage = function(msgParams, cb) {\n  const self = this\n  waterfall([\n    (cb) => self.approvePersonalMessage(msgParams, cb),\n    (didApprove, cb) => self.checkApproval('message', didApprove, cb),\n    (cb) => self.signPersonalMessage(msgParams, cb),\n  ], cb)\n}\n\nHookedWalletSubprovider.prototype.processDecryptMessage = function(msgParams, cb) {\n  const self = this\n  waterfall([\n    (cb) => self.approveDecryptMessage(msgParams, cb),\n    (didApprove, cb) => self.checkApproval('decryptMessage', didApprove, cb),\n    (cb) => self.decryptMessage(msgParams, cb),\n  ], cb)\n}\n\nHookedWalletSubprovider.prototype.processEncryptionPublicKey = function(msgParams, cb) {\n  const self = this\n  waterfall([\n    (cb) => self.approveEncryptionPublicKey(msgParams, cb),\n    (didApprove, cb) => self.checkApproval('encryptionPublicKey', didApprove, cb),\n    (cb) => self.encryptionPublicKey(msgParams, cb),\n  ], cb)\n}\n\nHookedWalletSubprovider.prototype.processTypedMessage = function(msgParams, cb) {\n  const self = this\n  waterfall([\n    (cb) => self.approveTypedMessage(msgParams, cb),\n    (didApprove, cb) => self.checkApproval('message', didApprove, cb),\n    (cb) => self.signTypedMessage(msgParams, cb),\n  ], cb)\n}\n\n//\n// approval\n//\n\nHookedWalletSubprovider.prototype.autoApprove = function(txParams, cb) {\n  cb(null, true)\n}\n\nHookedWalletSubprovider.prototype.checkApproval = function(type, didApprove, cb) {\n  cb( didApprove ? null : new Error('User denied '+type+' signature.') )\n}\n\n//\n// parity\n//\n\nHookedWalletSubprovider.prototype.parityPostTransaction = function(txParams, cb) {\n  const self = this\n\n  // get next id\n  const count = self._parityRequestCount\n  const reqId = `0x${count.toString(16)}`\n  self._parityRequestCount++\n\n  self.emitPayload({\n    method: 'eth_sendTransaction',\n    params: [txParams],\n  }, function(error, res){\n    if (error) {\n      self._parityRequests[reqId] = { error }\n      return\n    }\n    const txHash = res.result\n    self._parityRequests[reqId] = txHash\n  })\n\n  cb(null, reqId)\n}\n\n\nHookedWalletSubprovider.prototype.parityPostSign = function(address, message, cb) {\n  const self = this\n\n  // get next id\n  const count = self._parityRequestCount\n  const reqId = `0x${count.toString(16)}`\n  self._parityRequestCount++\n\n  self.emitPayload({\n    method: 'eth_sign',\n    params: [address, message],\n  }, function(error, res){\n    if (error) {\n      self._parityRequests[reqId] = { error }\n      return\n    }\n    const result = res.result\n    self._parityRequests[reqId] = result\n  })\n\n  cb(null, reqId)\n}\n\nHookedWalletSubprovider.prototype.parityCheckRequest = function(reqId, cb) {\n  const self = this\n  const result = self._parityRequests[reqId] || null\n  // tx not handled yet\n  if (!result) return cb(null, null)\n  // tx was rejected (or other error)\n  if (result.error) return cb(result.error)\n  // tx sent\n  cb(null, result)\n}\n\n//\n// signature and recovery\n//\n\nHookedWalletSubprovider.prototype.recoverPersonalSignature = function(msgParams, cb) {\n  let senderHex\n  try {\n    senderHex = sigUtil.recoverPersonalSignature(msgParams)\n  } catch (err) {\n    return cb(err)\n  }\n  cb(null, senderHex)\n}\n\n//\n// validation\n//\n\nHookedWalletSubprovider.prototype.validateTransaction = function(txParams, cb){\n  const self = this\n  // shortcut: undefined sender is invalid\n  if (txParams.from === undefined) return cb(new Error(`Undefined address - from address required to sign transaction.`))\n  self.validateSender(txParams.from, function(err, senderIsValid){\n    if (err) return cb(err)\n    if (!senderIsValid) return cb(new Error(`Unknown address - unable to sign transaction for this address: \"${txParams.from}\"`))\n    cb()\n  })\n}\n\nHookedWalletSubprovider.prototype.validateMessage = function(msgParams, cb){\n  const self = this\n  if (msgParams.from === undefined) return cb(new Error(`Undefined address - from address required to sign message.`))\n  self.validateSender(msgParams.from, function(err, senderIsValid){\n    if (err) return cb(err)\n    if (!senderIsValid) return cb(new Error(`Unknown address - unable to sign message for this address: \"${msgParams.from}\"`))\n    cb()\n  })\n}\n\nHookedWalletSubprovider.prototype.validatePersonalMessage = function(msgParams, cb){\n  const self = this\n  if (msgParams.from === undefined) return cb(new Error(`Undefined address - from address required to sign personal message.`))\n  if (msgParams.data === undefined) return cb(new Error(`Undefined message - message required to sign personal message.`))\n  if (!isValidHex(msgParams.data)) return cb(new Error(`HookedWalletSubprovider - validateMessage - message was not encoded as hex.`))\n  self.validateSender(msgParams.from, function(err, senderIsValid){\n    if (err) return cb(err)\n    if (!senderIsValid) return cb(new Error(`Unknown address - unable to sign message for this address: \"${msgParams.from}\"`))\n    cb()\n  })\n}\n\nHookedWalletSubprovider.prototype.validateDecryptMessage = function(msgParams, cb){\n  const self = this\n  if (msgParams.from === undefined) return cb(new Error(`Undefined address - from address required to decrypt message.`))\n  if (msgParams.data === undefined) return cb(new Error(`Undefined message - message required to decrypt message.`))\n  if (!isValidHex(msgParams.data)) return cb(new Error(`HookedWalletSubprovider - validateDecryptMessage - message was not encoded as hex.`))\n  self.validateSender(msgParams.from, function(err, senderIsValid){\n    if (err) return cb(err)\n    if (!senderIsValid) return cb(new Error(`Unknown address - unable to decrypt message for this address: \"${msgParams.from}\"`))\n    cb()\n  })\n}\n\nHookedWalletSubprovider.prototype.validateEncryptionPublicKey = function(address, cb){\n  const self = this\n\n  self.validateSender(address, function(err, senderIsValid){\n    if (err) return cb(err)\n    if (!senderIsValid) return cb(new Error(`Unknown address - unable to obtain encryption public key for this address: \"${address}\"`))\n    cb()\n  })\n}\n\nHookedWalletSubprovider.prototype.validateTypedMessage = function(msgParams, cb){\n  if (msgParams.from === undefined) return cb(new Error(`Undefined address - from address required to sign typed data.`))\n  if (msgParams.data === undefined) return cb(new Error(`Undefined data - message required to sign typed data.`))\n  this.validateSender(msgParams.from, function(err, senderIsValid){\n    if (err) return cb(err)\n    if (!senderIsValid) return cb(new Error(`Unknown address - unable to sign message for this address: \"${msgParams.from}\"`))\n    cb()\n  })\n}\n\nHookedWalletSubprovider.prototype.validateSender = function(senderAddress, cb){\n  const self = this\n  // shortcut: undefined sender is invalid\n  if (!senderAddress) return cb(null, false)\n  self.getAccounts(function(err, accounts){\n    if (err) return cb(err)\n    const senderIsValid = (accounts.map(toLowerCase).indexOf(senderAddress.toLowerCase()) !== -1)\n    cb(null, senderIsValid)\n  })\n}\n\n//\n// tx helpers\n//\n\nHookedWalletSubprovider.prototype.finalizeAndSubmitTx = function(txParams, cb) {\n  const self = this\n  // can only allow one tx to pass through this flow at a time\n  // so we can atomically consume a nonce\n  self.nonceLock.take(function(){\n    waterfall([\n      self.fillInTxExtras.bind(self, txParams),\n      self.signTransaction.bind(self),\n      self.publishTransaction.bind(self),\n    ], function(err, txHash){\n      self.nonceLock.leave()\n      if (err) return cb(err)\n      cb(null, txHash)\n    })\n  })\n}\n\nHookedWalletSubprovider.prototype.finalizeTx = function(txParams, cb) {\n  const self = this\n  // can only allow one tx to pass through this flow at a time\n  // so we can atomically consume a nonce\n  self.nonceLock.take(function(){\n    waterfall([\n      self.fillInTxExtras.bind(self, txParams),\n      self.signTransaction.bind(self),\n    ], function(err, signedTx){\n      self.nonceLock.leave()\n      if (err) return cb(err)\n      cb(null, {raw: signedTx, tx: txParams})\n    })\n  })\n}\n\nHookedWalletSubprovider.prototype.publishTransaction = function(rawTx, cb) {\n  const self = this\n  self.emitPayload({\n    method: 'eth_sendRawTransaction',\n    params: [rawTx],\n  }, function(err, res){\n    if (err) return cb(err)\n    cb(null, res.result)\n  })\n}\n\nHookedWalletSubprovider.prototype.estimateGas = function(txParams, cb) {\n  const self = this\n  estimateGas(self.engine, txParams, cb)\n}\n\nHookedWalletSubprovider.prototype.getGasPrice = function(cb) {\n  const self = this\n  self.emitPayload({ method: 'eth_gasPrice', params: [] }, function (err, res) {\n    if (err) return cb(err)\n    cb(null, res.result)\n  })\n}\n\nHookedWalletSubprovider.prototype.fillInTxExtras = function(txParams, cb){\n  const self = this\n  const address = txParams.from\n  // console.log('fillInTxExtras - address:', address)\n\n  const tasks = {}\n\n  if (txParams.gasPrice === undefined) {\n    // console.log(\"need to get gasprice\")\n    tasks.gasPrice = self.getGasPrice.bind(self)\n  }\n\n  if (txParams.nonce === undefined) {\n    // console.log(\"need to get nonce\")\n    tasks.nonce = self.emitPayload.bind(self, { method: 'eth_getTransactionCount', params: [address, 'pending'] })\n  }\n\n  if (txParams.gas === undefined) {\n    // console.log(\"need to get gas\")\n    tasks.gas = self.estimateGas.bind(self, cloneTxParams(txParams))\n  }\n\n  parallel(tasks, function(err, taskResults) {\n    if (err) return cb(err)\n\n    const result = {}\n    if (taskResults.gasPrice) result.gasPrice = taskResults.gasPrice\n    if (taskResults.nonce) result.nonce = taskResults.nonce.result\n    if (taskResults.gas) result.gas = taskResults.gas\n\n    cb(null, extend(txParams, result))\n  })\n}\n\n// util\n\n// we use this to clean any custom params from the txParams\nfunction cloneTxParams(txParams){\n  return {\n    from: txParams.from,\n    to: txParams.to,\n    value: txParams.value,\n    data: txParams.data,\n    gas: txParams.gas,\n    gasPrice: txParams.gasPrice,\n    nonce: txParams.nonce,\n  }\n}\n\nfunction toLowerCase(string){\n  return string.toLowerCase()\n}\n\nfunction resemblesAddress (string) {\n  const fixed = ethUtil.addHexPrefix(string)\n  const isValid = ethUtil.isValidAddress(fixed)\n  return isValid\n}\n\n// Returns true if resembles hex data\n// but definitely not a valid address.\nfunction resemblesData (string) {\n  const fixed = ethUtil.addHexPrefix(string)\n  const isValidAddress = ethUtil.isValidAddress(fixed)\n  return !isValidAddress && isValidHex(string)\n}\n\nfunction isValidHex(data) {\n  const isString = typeof data === 'string'\n  if (!isString) return false\n  const isHexPrefixed = data.slice(0,2) === '0x'\n  if (!isHexPrefixed) return false\n  const nonPrefixed = data.slice(2)\n  const isValid = nonPrefixed.match(hexRegex)\n  return isValid\n}\n\nfunction mustProvideInConstructor(methodName) {\n  return function(params, cb) {\n    cb(new Error('ProviderEngine - HookedWalletSubprovider - Must provide \"' + methodName + '\" fn in constructor options'))\n  }\n}\n"]},"metadata":{},"sourceType":"script"}