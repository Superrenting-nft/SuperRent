{"ast":null,"code":"\"use strict\";\n\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { arrayify, concat, hexlify, zeroPad } from \"@ethersproject/bytes\";\nimport { keccak256 as hashKeccak256 } from \"@ethersproject/keccak256\";\nimport { sha256 as hashSha256 } from \"@ethersproject/sha2\";\nimport { toUtf8Bytes } from \"@ethersproject/strings\";\nconst regexBytes = new RegExp(\"^bytes([0-9]+)$\");\nconst regexNumber = new RegExp(\"^(u?int)([0-9]*)$\");\nconst regexArray = new RegExp(\"^(.*)\\\\[([0-9]*)\\\\]$\");\nconst Zeros = \"0000000000000000000000000000000000000000000000000000000000000000\";\n\nfunction _pack(type, value, isArray) {\n  switch (type) {\n    case \"address\":\n      if (isArray) {\n        return zeroPad(value, 32);\n      }\n\n      return arrayify(value);\n\n    case \"string\":\n      return toUtf8Bytes(value);\n\n    case \"bytes\":\n      return arrayify(value);\n\n    case \"bool\":\n      value = value ? \"0x01\" : \"0x00\";\n\n      if (isArray) {\n        return zeroPad(value, 32);\n      }\n\n      return arrayify(value);\n  }\n\n  let match = type.match(regexNumber);\n\n  if (match) {\n    //let signed = (match[1] === \"int\")\n    let size = parseInt(match[2] || \"256\");\n\n    if (match[2] && String(size) !== match[2] || size % 8 !== 0 || size === 0 || size > 256) {\n      throw new Error(\"invalid number type - \" + type);\n    }\n\n    if (isArray) {\n      size = 256;\n    }\n\n    value = BigNumber.from(value).toTwos(size);\n    return zeroPad(value, size / 8);\n  }\n\n  match = type.match(regexBytes);\n\n  if (match) {\n    const size = parseInt(match[1]);\n\n    if (String(size) !== match[1] || size === 0 || size > 32) {\n      throw new Error(\"invalid bytes type - \" + type);\n    }\n\n    if (arrayify(value).byteLength !== size) {\n      throw new Error(\"invalid value for \" + type);\n    }\n\n    if (isArray) {\n      return arrayify((value + Zeros).substring(0, 66));\n    }\n\n    return value;\n  }\n\n  match = type.match(regexArray);\n\n  if (match && Array.isArray(value)) {\n    const baseType = match[1];\n    const count = parseInt(match[2] || String(value.length));\n\n    if (count != value.length) {\n      throw new Error(\"invalid value for \" + type);\n    }\n\n    const result = [];\n    value.forEach(function (value) {\n      result.push(_pack(baseType, value, true));\n    });\n    return concat(result);\n  }\n\n  throw new Error(\"invalid type - \" + type);\n} // @TODO: Array Enum\n\n\nexport function pack(types, values) {\n  if (types.length != values.length) {\n    throw new Error(\"type/value count mismatch\");\n  }\n\n  const tight = [];\n  types.forEach(function (type, index) {\n    tight.push(_pack(type, values[index]));\n  });\n  return hexlify(concat(tight));\n}\nexport function keccak256(types, values) {\n  return hashKeccak256(pack(types, values));\n}\nexport function sha256(types, values) {\n  return hashSha256(pack(types, values));\n}","map":{"version":3,"sources":["../src.ts/index.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { arrayify, concat, hexlify, zeroPad } from \"@ethersproject/bytes\";\nimport { keccak256 as hashKeccak256 } from \"@ethersproject/keccak256\";\nimport { sha256 as hashSha256 } from \"@ethersproject/sha2\";\nimport { toUtf8Bytes } from \"@ethersproject/strings\";\nconst regexBytes = new RegExp(\"^bytes([0-9]+)$\");\nconst regexNumber = new RegExp(\"^(u?int)([0-9]*)$\");\nconst regexArray = new RegExp(\"^(.*)\\\\[([0-9]*)\\\\]$\");\nconst Zeros = \"0000000000000000000000000000000000000000000000000000000000000000\";\nfunction _pack(type, value, isArray) {\n    switch (type) {\n        case \"address\":\n            if (isArray) {\n                return zeroPad(value, 32);\n            }\n            return arrayify(value);\n        case \"string\":\n            return toUtf8Bytes(value);\n        case \"bytes\":\n            return arrayify(value);\n        case \"bool\":\n            value = (value ? \"0x01\" : \"0x00\");\n            if (isArray) {\n                return zeroPad(value, 32);\n            }\n            return arrayify(value);\n    }\n    let match = type.match(regexNumber);\n    if (match) {\n        //let signed = (match[1] === \"int\")\n        let size = parseInt(match[2] || \"256\");\n        if ((match[2] && String(size) !== match[2]) || (size % 8 !== 0) || size === 0 || size > 256) {\n            throw new Error(\"invalid number type - \" + type);\n        }\n        if (isArray) {\n            size = 256;\n        }\n        value = BigNumber.from(value).toTwos(size);\n        return zeroPad(value, size / 8);\n    }\n    match = type.match(regexBytes);\n    if (match) {\n        const size = parseInt(match[1]);\n        if (String(size) !== match[1] || size === 0 || size > 32) {\n            throw new Error(\"invalid bytes type - \" + type);\n        }\n        if (arrayify(value).byteLength !== size) {\n            throw new Error(\"invalid value for \" + type);\n        }\n        if (isArray) {\n            return arrayify((value + Zeros).substring(0, 66));\n        }\n        return value;\n    }\n    match = type.match(regexArray);\n    if (match && Array.isArray(value)) {\n        const baseType = match[1];\n        const count = parseInt(match[2] || String(value.length));\n        if (count != value.length) {\n            throw new Error(\"invalid value for \" + type);\n        }\n        const result = [];\n        value.forEach(function (value) {\n            result.push(_pack(baseType, value, true));\n        });\n        return concat(result);\n    }\n    throw new Error(\"invalid type - \" + type);\n}\n// @TODO: Array Enum\nexport function pack(types, values) {\n    if (types.length != values.length) {\n        throw new Error(\"type/value count mismatch\");\n    }\n    const tight = [];\n    types.forEach(function (type, index) {\n        tight.push(_pack(type, values[index]));\n    });\n    return hexlify(concat(tight));\n}\nexport function keccak256(types, values) {\n    return hashKeccak256(pack(types, values));\n}\nexport function sha256(types, values) {\n    return hashSha256(pack(types, values));\n}\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"module"}