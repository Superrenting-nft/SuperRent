{"ast":null,"code":"\"use strict\";\n\nimport { formatFixed, parseFixed } from \"@ethersproject/bignumber\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nconst names = [\"wei\", \"kwei\", \"mwei\", \"gwei\", \"szabo\", \"finney\", \"ether\"]; // Some environments have issues with RegEx that contain back-tracking, so we cannot\n// use them.\n\nexport function commify(value) {\n  const comps = String(value).split(\".\");\n\n  if (comps.length > 2 || !comps[0].match(/^-?[0-9]*$/) || comps[1] && !comps[1].match(/^[0-9]*$/) || value === \".\" || value === \"-.\") {\n    logger.throwArgumentError(\"invalid value\", \"value\", value);\n  } // Make sure we have at least one whole digit (0 if none)\n\n\n  let whole = comps[0];\n  let negative = \"\";\n\n  if (whole.substring(0, 1) === \"-\") {\n    negative = \"-\";\n    whole = whole.substring(1);\n  } // Make sure we have at least 1 whole digit with no leading zeros\n\n\n  while (whole.substring(0, 1) === \"0\") {\n    whole = whole.substring(1);\n  }\n\n  if (whole === \"\") {\n    whole = \"0\";\n  }\n\n  let suffix = \"\";\n\n  if (comps.length === 2) {\n    suffix = \".\" + (comps[1] || \"0\");\n  }\n\n  while (suffix.length > 2 && suffix[suffix.length - 1] === \"0\") {\n    suffix = suffix.substring(0, suffix.length - 1);\n  }\n\n  const formatted = [];\n\n  while (whole.length) {\n    if (whole.length <= 3) {\n      formatted.unshift(whole);\n      break;\n    } else {\n      const index = whole.length - 3;\n      formatted.unshift(whole.substring(index));\n      whole = whole.substring(0, index);\n    }\n  }\n\n  return negative + formatted.join(\",\") + suffix;\n}\nexport function formatUnits(value, unitName) {\n  if (typeof unitName === \"string\") {\n    const index = names.indexOf(unitName);\n\n    if (index !== -1) {\n      unitName = 3 * index;\n    }\n  }\n\n  return formatFixed(value, unitName != null ? unitName : 18);\n}\nexport function parseUnits(value, unitName) {\n  if (typeof value !== \"string\") {\n    logger.throwArgumentError(\"value must be a string\", \"value\", value);\n  }\n\n  if (typeof unitName === \"string\") {\n    const index = names.indexOf(unitName);\n\n    if (index !== -1) {\n      unitName = 3 * index;\n    }\n  }\n\n  return parseFixed(value, unitName != null ? unitName : 18);\n}\nexport function formatEther(wei) {\n  return formatUnits(wei, 18);\n}\nexport function parseEther(ether) {\n  return parseUnits(ether, 18);\n}","map":{"version":3,"sources":["../src.ts/index.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nimport { formatFixed, parseFixed } from \"@ethersproject/bignumber\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nconst names = [\n    \"wei\",\n    \"kwei\",\n    \"mwei\",\n    \"gwei\",\n    \"szabo\",\n    \"finney\",\n    \"ether\",\n];\n// Some environments have issues with RegEx that contain back-tracking, so we cannot\n// use them.\nexport function commify(value) {\n    const comps = String(value).split(\".\");\n    if (comps.length > 2 || !comps[0].match(/^-?[0-9]*$/) || (comps[1] && !comps[1].match(/^[0-9]*$/)) || value === \".\" || value === \"-.\") {\n        logger.throwArgumentError(\"invalid value\", \"value\", value);\n    }\n    // Make sure we have at least one whole digit (0 if none)\n    let whole = comps[0];\n    let negative = \"\";\n    if (whole.substring(0, 1) === \"-\") {\n        negative = \"-\";\n        whole = whole.substring(1);\n    }\n    // Make sure we have at least 1 whole digit with no leading zeros\n    while (whole.substring(0, 1) === \"0\") {\n        whole = whole.substring(1);\n    }\n    if (whole === \"\") {\n        whole = \"0\";\n    }\n    let suffix = \"\";\n    if (comps.length === 2) {\n        suffix = \".\" + (comps[1] || \"0\");\n    }\n    while (suffix.length > 2 && suffix[suffix.length - 1] === \"0\") {\n        suffix = suffix.substring(0, suffix.length - 1);\n    }\n    const formatted = [];\n    while (whole.length) {\n        if (whole.length <= 3) {\n            formatted.unshift(whole);\n            break;\n        }\n        else {\n            const index = whole.length - 3;\n            formatted.unshift(whole.substring(index));\n            whole = whole.substring(0, index);\n        }\n    }\n    return negative + formatted.join(\",\") + suffix;\n}\nexport function formatUnits(value, unitName) {\n    if (typeof (unitName) === \"string\") {\n        const index = names.indexOf(unitName);\n        if (index !== -1) {\n            unitName = 3 * index;\n        }\n    }\n    return formatFixed(value, (unitName != null) ? unitName : 18);\n}\nexport function parseUnits(value, unitName) {\n    if (typeof (value) !== \"string\") {\n        logger.throwArgumentError(\"value must be a string\", \"value\", value);\n    }\n    if (typeof (unitName) === \"string\") {\n        const index = names.indexOf(unitName);\n        if (index !== -1) {\n            unitName = 3 * index;\n        }\n    }\n    return parseFixed(value, (unitName != null) ? unitName : 18);\n}\nexport function formatEther(wei) {\n    return formatUnits(wei, 18);\n}\nexport function parseEther(ether) {\n    return parseUnits(ether, 18);\n}\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"module"}