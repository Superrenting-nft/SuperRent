{"ast":null,"code":"\"use strict\";\n\nimport { arrayify, hexlify } from \"@ethersproject/bytes\";\nimport { computeHmac } from \"@ethersproject/sha2\";\nexport function pbkdf2(password, salt, iterations, keylen, hashAlgorithm) {\n  password = arrayify(password);\n  salt = arrayify(salt);\n  let hLen;\n  let l = 1;\n  const DK = new Uint8Array(keylen);\n  const block1 = new Uint8Array(salt.length + 4);\n  block1.set(salt); //salt.copy(block1, 0, 0, salt.length)\n\n  let r;\n  let T;\n\n  for (let i = 1; i <= l; i++) {\n    //block1.writeUInt32BE(i, salt.length)\n    block1[salt.length] = i >> 24 & 0xff;\n    block1[salt.length + 1] = i >> 16 & 0xff;\n    block1[salt.length + 2] = i >> 8 & 0xff;\n    block1[salt.length + 3] = i & 0xff; //let U = createHmac(password).update(block1).digest();\n\n    let U = arrayify(computeHmac(hashAlgorithm, password, block1));\n\n    if (!hLen) {\n      hLen = U.length;\n      T = new Uint8Array(hLen);\n      l = Math.ceil(keylen / hLen);\n      r = keylen - (l - 1) * hLen;\n    } //U.copy(T, 0, 0, hLen)\n\n\n    T.set(U);\n\n    for (let j = 1; j < iterations; j++) {\n      //U = createHmac(password).update(U).digest();\n      U = arrayify(computeHmac(hashAlgorithm, password, U));\n\n      for (let k = 0; k < hLen; k++) T[k] ^= U[k];\n    }\n\n    const destPos = (i - 1) * hLen;\n    const len = i === l ? r : hLen; //T.copy(DK, destPos, 0, len)\n\n    DK.set(arrayify(T).slice(0, len), destPos);\n  }\n\n  return hexlify(DK);\n}","map":{"version":3,"sources":["../src.ts/browser-pbkdf2.ts"],"names":[],"mappings":"AAAA;;AAEA,SAAS,QAAT,EAA8B,OAA9B,QAA6C,sBAA7C;AACA,SAAS,WAAT,QAAgD,qBAAhD;AAEA,OAAM,SAAU,MAAV,CAAiB,QAAjB,EAAsC,IAAtC,EAAuD,UAAvD,EAA2E,MAA3E,EAA2F,aAA3F,EAAgH;AAClH,EAAA,QAAQ,GAAG,QAAQ,CAAC,QAAD,CAAnB;AACA,EAAA,IAAI,GAAG,QAAQ,CAAC,IAAD,CAAf;AACA,MAAI,IAAJ;AACA,MAAI,CAAC,GAAG,CAAR;AACA,QAAM,EAAE,GAAG,IAAI,UAAJ,CAAe,MAAf,CAAX;AACA,QAAM,MAAM,GAAG,IAAI,UAAJ,CAAe,IAAI,CAAC,MAAL,GAAc,CAA7B,CAAf;AACA,EAAA,MAAM,CAAC,GAAP,CAAW,IAAX,EAPkH,CAQlH;;AAEA,MAAI,CAAJ;AACA,MAAI,CAAJ;;AAEA,OAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,IAAI,CAArB,EAAwB,CAAC,EAAzB,EAA6B;AACzB;AACA,IAAA,MAAM,CAAC,IAAI,CAAC,MAAN,CAAN,GAAuB,CAAC,IAAI,EAAN,GAAY,IAAlC;AACA,IAAA,MAAM,CAAC,IAAI,CAAC,MAAL,GAAc,CAAf,CAAN,GAA2B,CAAC,IAAI,EAAN,GAAY,IAAtC;AACA,IAAA,MAAM,CAAC,IAAI,CAAC,MAAL,GAAc,CAAf,CAAN,GAA2B,CAAC,IAAI,CAAN,GAAW,IAArC;AACA,IAAA,MAAM,CAAC,IAAI,CAAC,MAAL,GAAc,CAAf,CAAN,GAA0B,CAAC,GAAG,IAA9B,CALyB,CAOzB;;AACA,QAAI,CAAC,GAAG,QAAQ,CAAC,WAAW,CAAqB,aAArB,EAAoC,QAApC,EAA8C,MAA9C,CAAZ,CAAhB;;AAEA,QAAI,CAAC,IAAL,EAAW;AACP,MAAA,IAAI,GAAG,CAAC,CAAC,MAAT;AACA,MAAA,CAAC,GAAG,IAAI,UAAJ,CAAe,IAAf,CAAJ;AACA,MAAA,CAAC,GAAG,IAAI,CAAC,IAAL,CAAU,MAAM,GAAG,IAAnB,CAAJ;AACA,MAAA,CAAC,GAAG,MAAM,GAAG,CAAC,CAAC,GAAG,CAAL,IAAU,IAAvB;AACH,KAfwB,CAiBzB;;;AACA,IAAA,CAAC,CAAC,GAAF,CAAM,CAAN;;AAGA,SAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,UAApB,EAAgC,CAAC,EAAjC,EAAqC;AACjC;AACA,MAAA,CAAC,GAAG,QAAQ,CAAC,WAAW,CAAqB,aAArB,EAAoC,QAApC,EAA8C,CAA9C,CAAZ,CAAZ;;AACA,WAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,IAApB,EAA0B,CAAC,EAA3B,EAA+B,CAAC,CAAC,CAAD,CAAD,IAAQ,CAAC,CAAC,CAAD,CAAT;AAClC;;AAGD,UAAM,OAAO,GAAG,CAAC,CAAC,GAAG,CAAL,IAAU,IAA1B;AACA,UAAM,GAAG,GAAI,CAAC,KAAK,CAAN,GAAU,CAAV,GAAc,IAA3B,CA7ByB,CA8BzB;;AACA,IAAA,EAAE,CAAC,GAAH,CAAO,QAAQ,CAAC,CAAD,CAAR,CAAY,KAAZ,CAAkB,CAAlB,EAAqB,GAArB,CAAP,EAAkC,OAAlC;AACH;;AAED,SAAO,OAAO,CAAC,EAAD,CAAd;AACH","sourceRoot":"","sourcesContent":["\"use strict\";\nimport { arrayify, hexlify } from \"@ethersproject/bytes\";\nimport { computeHmac } from \"@ethersproject/sha2\";\nexport function pbkdf2(password, salt, iterations, keylen, hashAlgorithm) {\n    password = arrayify(password);\n    salt = arrayify(salt);\n    let hLen;\n    let l = 1;\n    const DK = new Uint8Array(keylen);\n    const block1 = new Uint8Array(salt.length + 4);\n    block1.set(salt);\n    //salt.copy(block1, 0, 0, salt.length)\n    let r;\n    let T;\n    for (let i = 1; i <= l; i++) {\n        //block1.writeUInt32BE(i, salt.length)\n        block1[salt.length] = (i >> 24) & 0xff;\n        block1[salt.length + 1] = (i >> 16) & 0xff;\n        block1[salt.length + 2] = (i >> 8) & 0xff;\n        block1[salt.length + 3] = i & 0xff;\n        //let U = createHmac(password).update(block1).digest();\n        let U = arrayify(computeHmac(hashAlgorithm, password, block1));\n        if (!hLen) {\n            hLen = U.length;\n            T = new Uint8Array(hLen);\n            l = Math.ceil(keylen / hLen);\n            r = keylen - (l - 1) * hLen;\n        }\n        //U.copy(T, 0, 0, hLen)\n        T.set(U);\n        for (let j = 1; j < iterations; j++) {\n            //U = createHmac(password).update(U).digest();\n            U = arrayify(computeHmac(hashAlgorithm, password, U));\n            for (let k = 0; k < hLen; k++)\n                T[k] ^= U[k];\n        }\n        const destPos = (i - 1) * hLen;\n        const len = (i === l ? r : hLen);\n        //T.copy(DK, destPos, 0, len)\n        DK.set(arrayify(T).slice(0, len), destPos);\n    }\n    return hexlify(DK);\n}\n//# sourceMappingURL=pbkdf2.js.map"]},"metadata":{},"sourceType":"module"}