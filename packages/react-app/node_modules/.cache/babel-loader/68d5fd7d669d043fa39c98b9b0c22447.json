{"ast":null,"code":"var BufferUtil = require('../utils/buffer');\n\nvar Polynomial = require('./polynomial');\n\nvar Buffer = require('buffer').Buffer;\n\nfunction ReedSolomonEncoder(degree) {\n  this.genPoly = undefined;\n  this.degree = degree;\n  if (this.degree) this.initialize(this.degree);\n}\n/**\n * Initialize the encoder.\n * The input param should correspond to the number of error correction codewords.\n *\n * @param  {Number} degree\n */\n\n\nReedSolomonEncoder.prototype.initialize = function initialize(degree) {\n  // create an irreducible generator polynomial\n  this.degree = degree;\n  this.genPoly = Polynomial.generateECPolynomial(this.degree);\n};\n/**\n * Encodes a chunk of data\n *\n * @param  {Buffer} data Buffer containing input data\n * @return {Buffer}      Buffer containing encoded data\n */\n\n\nReedSolomonEncoder.prototype.encode = function encode(data) {\n  if (!this.genPoly) {\n    throw new Error('Encoder not initialized');\n  } // Calculate EC for this data block\n  // extends data size to data+genPoly size\n\n\n  var pad = BufferUtil.alloc(this.degree);\n  var paddedData = Buffer.concat([data, pad], data.length + this.degree); // The error correction codewords are the remainder after dividing the data codewords\n  // by a generator polynomial\n\n  var remainder = Polynomial.mod(paddedData, this.genPoly); // return EC data blocks (last n byte, where n is the degree of genPoly)\n  // If coefficients number in remainder are less than genPoly degree,\n  // pad with 0s to the left to reach the needed number of coefficients\n\n  var start = this.degree - remainder.length;\n\n  if (start > 0) {\n    var buff = BufferUtil.alloc(this.degree);\n    remainder.copy(buff, start);\n    return buff;\n  }\n\n  return remainder;\n};\n\nmodule.exports = ReedSolomonEncoder;","map":{"version":3,"sources":["/Users/Antonio/Desktop/SuperRent/node_modules/qrcode/lib/core/reed-solomon-encoder.js"],"names":["BufferUtil","require","Polynomial","Buffer","ReedSolomonEncoder","degree","genPoly","undefined","initialize","prototype","generateECPolynomial","encode","data","Error","pad","alloc","paddedData","concat","length","remainder","mod","start","buff","copy","module","exports"],"mappings":"AAAA,IAAIA,UAAU,GAAGC,OAAO,CAAC,iBAAD,CAAxB;;AACA,IAAIC,UAAU,GAAGD,OAAO,CAAC,cAAD,CAAxB;;AACA,IAAIE,MAAM,GAAGF,OAAO,CAAC,QAAD,CAAP,CAAkBE,MAA/B;;AAEA,SAASC,kBAAT,CAA6BC,MAA7B,EAAqC;AACnC,OAAKC,OAAL,GAAeC,SAAf;AACA,OAAKF,MAAL,GAAcA,MAAd;AAEA,MAAI,KAAKA,MAAT,EAAiB,KAAKG,UAAL,CAAgB,KAAKH,MAArB;AAClB;AAED;AACA;AACA;AACA;AACA;AACA;;;AACAD,kBAAkB,CAACK,SAAnB,CAA6BD,UAA7B,GAA0C,SAASA,UAAT,CAAqBH,MAArB,EAA6B;AACrE;AACA,OAAKA,MAAL,GAAcA,MAAd;AACA,OAAKC,OAAL,GAAeJ,UAAU,CAACQ,oBAAX,CAAgC,KAAKL,MAArC,CAAf;AACD,CAJD;AAMA;AACA;AACA;AACA;AACA;AACA;;;AACAD,kBAAkB,CAACK,SAAnB,CAA6BE,MAA7B,GAAsC,SAASA,MAAT,CAAiBC,IAAjB,EAAuB;AAC3D,MAAI,CAAC,KAAKN,OAAV,EAAmB;AACjB,UAAM,IAAIO,KAAJ,CAAU,yBAAV,CAAN;AACD,GAH0D,CAK3D;AACA;;;AACA,MAAIC,GAAG,GAAGd,UAAU,CAACe,KAAX,CAAiB,KAAKV,MAAtB,CAAV;AACA,MAAIW,UAAU,GAAGb,MAAM,CAACc,MAAP,CAAc,CAACL,IAAD,EAAOE,GAAP,CAAd,EAA2BF,IAAI,CAACM,MAAL,GAAc,KAAKb,MAA9C,CAAjB,CAR2D,CAU3D;AACA;;AACA,MAAIc,SAAS,GAAGjB,UAAU,CAACkB,GAAX,CAAeJ,UAAf,EAA2B,KAAKV,OAAhC,CAAhB,CAZ2D,CAc3D;AACA;AACA;;AACA,MAAIe,KAAK,GAAG,KAAKhB,MAAL,GAAcc,SAAS,CAACD,MAApC;;AACA,MAAIG,KAAK,GAAG,CAAZ,EAAe;AACb,QAAIC,IAAI,GAAGtB,UAAU,CAACe,KAAX,CAAiB,KAAKV,MAAtB,CAAX;AACAc,IAAAA,SAAS,CAACI,IAAV,CAAeD,IAAf,EAAqBD,KAArB;AAEA,WAAOC,IAAP;AACD;;AAED,SAAOH,SAAP;AACD,CA1BD;;AA4BAK,MAAM,CAACC,OAAP,GAAiBrB,kBAAjB","sourcesContent":["var BufferUtil = require('../utils/buffer')\nvar Polynomial = require('./polynomial')\nvar Buffer = require('buffer').Buffer\n\nfunction ReedSolomonEncoder (degree) {\n  this.genPoly = undefined\n  this.degree = degree\n\n  if (this.degree) this.initialize(this.degree)\n}\n\n/**\n * Initialize the encoder.\n * The input param should correspond to the number of error correction codewords.\n *\n * @param  {Number} degree\n */\nReedSolomonEncoder.prototype.initialize = function initialize (degree) {\n  // create an irreducible generator polynomial\n  this.degree = degree\n  this.genPoly = Polynomial.generateECPolynomial(this.degree)\n}\n\n/**\n * Encodes a chunk of data\n *\n * @param  {Buffer} data Buffer containing input data\n * @return {Buffer}      Buffer containing encoded data\n */\nReedSolomonEncoder.prototype.encode = function encode (data) {\n  if (!this.genPoly) {\n    throw new Error('Encoder not initialized')\n  }\n\n  // Calculate EC for this data block\n  // extends data size to data+genPoly size\n  var pad = BufferUtil.alloc(this.degree)\n  var paddedData = Buffer.concat([data, pad], data.length + this.degree)\n\n  // The error correction codewords are the remainder after dividing the data codewords\n  // by a generator polynomial\n  var remainder = Polynomial.mod(paddedData, this.genPoly)\n\n  // return EC data blocks (last n byte, where n is the degree of genPoly)\n  // If coefficients number in remainder are less than genPoly degree,\n  // pad with 0s to the left to reach the needed number of coefficients\n  var start = this.degree - remainder.length\n  if (start > 0) {\n    var buff = BufferUtil.alloc(this.degree)\n    remainder.copy(buff, start)\n\n    return buff\n  }\n\n  return remainder\n}\n\nmodule.exports = ReedSolomonEncoder\n"]},"metadata":{},"sourceType":"script"}