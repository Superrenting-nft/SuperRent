{"ast":null,"code":"\"use strict\";\n\nimport aes from \"aes-js\";\nimport { getAddress } from \"@ethersproject/address\";\nimport { arrayify } from \"@ethersproject/bytes\";\nimport { keccak256 } from \"@ethersproject/keccak256\";\nimport { pbkdf2 } from \"@ethersproject/pbkdf2\";\nimport { toUtf8Bytes } from \"@ethersproject/strings\";\nimport { Description } from \"@ethersproject/properties\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nimport { getPassword, looseArrayify, searchPath } from \"./utils\";\nexport class CrowdsaleAccount extends Description {\n  isCrowdsaleAccount(value) {\n    return !!(value && value._isCrowdsaleAccount);\n  }\n\n} // See: https://github.com/ethereum/pyethsaletool\n\nexport function decrypt(json, password) {\n  const data = JSON.parse(json);\n  password = getPassword(password); // Ethereum Address\n\n  const ethaddr = getAddress(searchPath(data, \"ethaddr\")); // Encrypted Seed\n\n  const encseed = looseArrayify(searchPath(data, \"encseed\"));\n\n  if (!encseed || encseed.length % 16 !== 0) {\n    logger.throwArgumentError(\"invalid encseed\", \"json\", json);\n  }\n\n  const key = arrayify(pbkdf2(password, password, 2000, 32, \"sha256\")).slice(0, 16);\n  const iv = encseed.slice(0, 16);\n  const encryptedSeed = encseed.slice(16); // Decrypt the seed\n\n  const aesCbc = new aes.ModeOfOperation.cbc(key, iv);\n  const seed = aes.padding.pkcs7.strip(arrayify(aesCbc.decrypt(encryptedSeed))); // This wallet format is weird... Convert the binary encoded hex to a string.\n\n  let seedHex = \"\";\n\n  for (let i = 0; i < seed.length; i++) {\n    seedHex += String.fromCharCode(seed[i]);\n  }\n\n  const seedHexBytes = toUtf8Bytes(seedHex);\n  const privateKey = keccak256(seedHexBytes);\n  return new CrowdsaleAccount({\n    _isCrowdsaleAccount: true,\n    address: ethaddr,\n    privateKey: privateKey\n  });\n}","map":{"version":3,"sources":["../src.ts/crowdsale.ts"],"names":[],"mappings":"AAAA;;AAEA,OAAO,GAAP,MAAgB,QAAhB;AAGA,SAAS,UAAT,QAA2B,wBAA3B;AACA,SAAS,QAAT,QAAgC,sBAAhC;AACA,SAAS,SAAT,QAA0B,0BAA1B;AACA,SAAS,MAAT,QAAuB,uBAAvB;AACA,SAAS,WAAT,QAA4B,wBAA5B;AACA,SAAS,WAAT,QAA4B,2BAA5B;AAEA,SAAS,MAAT,QAAuB,uBAAvB;AACA,SAAS,OAAT,QAAwB,YAAxB;AACA,MAAM,MAAM,GAAG,IAAI,MAAJ,CAAW,OAAX,CAAf;AAEA,SAAS,WAAT,EAAsB,aAAtB,EAAqC,UAArC,QAAuD,SAAvD;AASA,OAAM,MAAO,gBAAP,SAAgC,WAAhC,CAA8D;AAQhE,EAAA,kBAAkB,CAAC,KAAD,EAAW;AACzB,WAAO,CAAC,EAAE,KAAK,IAAI,KAAK,CAAC,mBAAjB,CAAR;AACH;;AAV+D,C,CAapE;;AACA,OAAM,SAAU,OAAV,CAAkB,IAAlB,EAAgC,QAAhC,EAAwD;AAC1D,QAAM,IAAI,GAAG,IAAI,CAAC,KAAL,CAAW,IAAX,CAAb;AAEA,EAAA,QAAQ,GAAG,WAAW,CAAC,QAAD,CAAtB,CAH0D,CAK1D;;AACA,QAAM,OAAO,GAAG,UAAU,CAAC,UAAU,CAAC,IAAD,EAAO,SAAP,CAAX,CAA1B,CAN0D,CAQ1D;;AACA,QAAM,OAAO,GAAG,aAAa,CAAC,UAAU,CAAC,IAAD,EAAO,SAAP,CAAX,CAA7B;;AACA,MAAI,CAAC,OAAD,IAAa,OAAO,CAAC,MAAR,GAAiB,EAAlB,KAA0B,CAA1C,EAA6C;AACzC,IAAA,MAAM,CAAC,kBAAP,CAA0B,iBAA1B,EAA6C,MAA7C,EAAqD,IAArD;AACH;;AAED,QAAM,GAAG,GAAG,QAAQ,CAAC,MAAM,CAAC,QAAD,EAAW,QAAX,EAAqB,IAArB,EAA2B,EAA3B,EAA+B,QAA/B,CAAP,CAAR,CAAyD,KAAzD,CAA+D,CAA/D,EAAkE,EAAlE,CAAZ;AAEA,QAAM,EAAE,GAAG,OAAO,CAAC,KAAR,CAAc,CAAd,EAAiB,EAAjB,CAAX;AACA,QAAM,aAAa,GAAG,OAAO,CAAC,KAAR,CAAc,EAAd,CAAtB,CAjB0D,CAmB1D;;AACA,QAAM,MAAM,GAAG,IAAI,GAAG,CAAC,eAAJ,CAAoB,GAAxB,CAA4B,GAA5B,EAAiC,EAAjC,CAAf;AACA,QAAM,IAAI,GAAG,GAAG,CAAC,OAAJ,CAAY,KAAZ,CAAkB,KAAlB,CAAwB,QAAQ,CAAC,MAAM,CAAC,OAAP,CAAe,aAAf,CAAD,CAAhC,CAAb,CArB0D,CAuB1D;;AACA,MAAI,OAAO,GAAG,EAAd;;AACA,OAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,IAAI,CAAC,MAAzB,EAAiC,CAAC,EAAlC,EAAsC;AAClC,IAAA,OAAO,IAAI,MAAM,CAAC,YAAP,CAAoB,IAAI,CAAC,CAAD,CAAxB,CAAX;AACH;;AAED,QAAM,YAAY,GAAG,WAAW,CAAC,OAAD,CAAhC;AAEA,QAAM,UAAU,GAAG,SAAS,CAAC,YAAD,CAA5B;AAEA,SAAO,IAAI,gBAAJ,CAAsB;AACzB,IAAA,mBAAmB,EAAE,IADI;AAEzB,IAAA,OAAO,EAAE,OAFgB;AAGzB,IAAA,UAAU,EAAE;AAHa,GAAtB,CAAP;AAKH","sourceRoot":"","sourcesContent":["\"use strict\";\nimport aes from \"aes-js\";\nimport { getAddress } from \"@ethersproject/address\";\nimport { arrayify } from \"@ethersproject/bytes\";\nimport { keccak256 } from \"@ethersproject/keccak256\";\nimport { pbkdf2 } from \"@ethersproject/pbkdf2\";\nimport { toUtf8Bytes } from \"@ethersproject/strings\";\nimport { Description } from \"@ethersproject/properties\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nimport { getPassword, looseArrayify, searchPath } from \"./utils\";\nexport class CrowdsaleAccount extends Description {\n    isCrowdsaleAccount(value) {\n        return !!(value && value._isCrowdsaleAccount);\n    }\n}\n// See: https://github.com/ethereum/pyethsaletool\nexport function decrypt(json, password) {\n    const data = JSON.parse(json);\n    password = getPassword(password);\n    // Ethereum Address\n    const ethaddr = getAddress(searchPath(data, \"ethaddr\"));\n    // Encrypted Seed\n    const encseed = looseArrayify(searchPath(data, \"encseed\"));\n    if (!encseed || (encseed.length % 16) !== 0) {\n        logger.throwArgumentError(\"invalid encseed\", \"json\", json);\n    }\n    const key = arrayify(pbkdf2(password, password, 2000, 32, \"sha256\")).slice(0, 16);\n    const iv = encseed.slice(0, 16);\n    const encryptedSeed = encseed.slice(16);\n    // Decrypt the seed\n    const aesCbc = new aes.ModeOfOperation.cbc(key, iv);\n    const seed = aes.padding.pkcs7.strip(arrayify(aesCbc.decrypt(encryptedSeed)));\n    // This wallet format is weird... Convert the binary encoded hex to a string.\n    let seedHex = \"\";\n    for (let i = 0; i < seed.length; i++) {\n        seedHex += String.fromCharCode(seed[i]);\n    }\n    const seedHexBytes = toUtf8Bytes(seedHex);\n    const privateKey = keccak256(seedHexBytes);\n    return new CrowdsaleAccount({\n        _isCrowdsaleAccount: true,\n        address: ethaddr,\n        privateKey: privateKey\n    });\n}\n//# sourceMappingURL=crowdsale.js.map"]},"metadata":{},"sourceType":"module"}